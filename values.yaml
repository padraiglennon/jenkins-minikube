# -- Override the deployment namespace
# @default -- `Release.Namespace`
namespaceOverride: "jenkins"

controller:
  # -- Resource allocation (Requests and Limits)
  resources:
    requests:
      cpu: "50m"
      memory: "256Mi"
    limits:
      cpu: "2000m"
      memory: "4096Mi"


  # -- Set Jenkins URL if you are not using the ingress definitions provided by the chart
  jenkinsUrl: "https://localhost:8443/jenkins"

  # -- Set Jenkins URI prefix for running behind a reverse proxy
  jenkinsUriPrefix: "/jenkins"

  # Plugins will be installed during Jenkins controller start
  # -- List of Jenkins plugins to install. If you don't want to install plugins, set it to `false`
  installPlugins:
    - kubernetes:4423.vb_59f230b_ce53
    - workflow-aggregator:608.v67378e9d3db_1
    - git:5.9.0
    - configuration-as-code:2037.v8e5349845172

  # If set to false, Jenkins will download the minimum required version of all dependencies.
  # -- Download the minimum required version or latest version of all dependencies
  installLatestPlugins: true

  # -- Set to true to download the latest version of any plugin that is requested to have the latest version
  installLatestSpecifiedPlugins: false

  # -- List of plugins to install in addition to those listed in controller.installPlugins
  additionalPlugins: 
    - cloudbees-disk-usage-simple:256.v20ec4eb_884f1
    - customizable-header:267.v8b_74097f488d
    - docker-workflow:634.vedc7242b_eda_7
    - metrics:4.2.37-494.v06f9a_939d33a_
    - prometheus:847.v8440e5c21e7c
    - pipeline-graph-view:763.v0e91db_e845ee
    - purge-build-queue-plugin:125.v09ee2147746f


  initScripts: {}
  #  test: |-
  #    print 'adding global pipeline libraries, register properties, bootstrap jobs...'
  # -- Name of the existing ConfigMap that contains init scripts
  initConfigMap: "smoke-tests-init-scripts"

  # 'name' is a name of an existing secret in the same namespace as jenkins,
  # 'keyName' is the name of one of the keys inside the current secret.
  # the 'name' and 'keyName' are concatenated with a '-' in between, so for example:
  # an existing secret "secret-credentials" and a key inside it named "github-password" should be used in JCasC as ${secret-credentials-github-password}
  # 'name' and 'keyName' must be lowercase RFC 1123 label must consist of lower case alphanumeric characters or '-',
  # and must start and end with an alphanumeric character (e.g. 'my-name', or '123-abc')
  # existingSecret existing secret "secret-credentials" and a key inside it named "github-username" should be used in JCasC as ${github-username}
  # When using existingSecret no need to specify the keyName under additionalExistingSecrets.
  existingSecret:

  # -- List of additional existing secrets to mount
  additionalExistingSecrets:
    - name: jenkins-admin-password
      keyName: password
  # ref: https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/secrets.adoc#kubernetes-secrets

  # -- List of additional secrets to create and mount
  additionalSecrets: []
  # ref: https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/secrets.adoc#kubernetes-secrets
  # additionalSecrets:
  #  - name: nameOfSecret
  #    value: secretText

  # Generate SecretClaim resources to create Kubernetes secrets from HashiCorp Vault using kube-vault-controller.
  # 'name' is the name of the secret that will be created in Kubernetes. The Jenkins fullname is prepended to this value.
  # 'path' is the fully qualified path to the secret in Vault
  # 'type' is an optional Kubernetes secret type. The default is 'Opaque'
  # 'renew' is an optional secret renewal time in seconds
  # -- List of `SecretClaim` resources to create
  secretClaims: []
  # - name: secretName        # required
  #   path: testPath          # required
  #   type: kubernetes.io/tls # optional
  #   renew: 60               # optional

  # -- Name of default cloud configuration.
  cloudName: "kubernetes"

  # Below is the implementation of Jenkins Configuration as Code. Add a key under configScripts for each configuration area,
  # where each corresponds to a plugin or section of the UI. Each key (prior to | character) is just a label, and can be any value.
  # Keys are only used to give the section a meaningful name. The only restriction is they may only contain RFC 1123 \ DNS label
  # characters: lowercase letters, numbers, and hyphens. The keys become the name of a configuration yaml file on the controller in
  # /var/jenkins_home/casc_configs (by default) and will be processed by the Configuration as Code Plugin. The lines after each |
  # become the content of the configuration yaml file. The first line after this is a JCasC root element, e.g., jenkins, credentials,
  # etc. Best reference is https://<jenkins_url>/configuration-as-code/reference. The example below creates a welcome message:
  JCasC:
    # -- Enables default Jenkins configuration via configuration as code plugin
    defaultConfig: true

    # If true, the init container deletes all the plugin config files and Jenkins Config as Code overwrites any existing configuration
    # -- Whether Jenkins Config as Code should overwrite any existing configuration
    overwriteConfiguration: false
    # -- Remote URLs for configuration files.
    configUrls: []
    # - https://acme.org/jenkins.yaml
    # -- List of Jenkins Config as Code scripts
    configScripts:
      welcome-message: |
        jenkins:
          systemMessage: Welcome to my personal CI/CD server.
      appearance: |
        appearance:
          consoleUrlProvider: {}
          customHeader:
            enabled: true
            header: "jenkins"
            headerColor:
              backgroundColor: "var(--accent-color)"
              color: "var(--white)"
            logo: "default"
            logoText: "Personal Jenkins"
            thinHeader: false
          pipelineGraphView:
            showGraphOnBuildPage: false
            showGraphOnJobPage: false
            showStageDurations: false
            showStageNames: false
      security: |
        security:
          contentSecurityPolicy:
            enforce: true

    # Ignored if securityRealm is defined in controller.JCasC.configScripts
    # -- Jenkins Config as Code Security Realm-section
    securityRealm: |-
      local:
        allowsSignup: false
        enableCaptcha: false
        users:
        - id: "${chart-admin-username}"
          name: "Jenkins Admin"
          password: "${jenkins-admin-password}"

  # -- Custom init-container specification in raw-yaml format
  customInitContainers: []
  # - name: custom-init
  #   image: "alpine:3"
  #   imagePullPolicy: Always
  #   command: [ "uname", "-a" ]

  sidecars:
    configAutoReload:
      # If enabled: true, Jenkins Configuration as Code will be reloaded on-the-fly without a reboot.
      # If false or not-specified, JCasC changes will cause a reboot and will only be applied at the subsequent start-up.
      # Auto-reload uses the http://<jenkins_url>/reload-configuration-as-code endpoint to reapply config when changes to
      # the configScripts are detected.
      # -- Enable Jenkins Config as Code auto-reload
      enabled: true
      image:
        # -- Registry for the image that triggers the reload
        registry: docker.io
        # -- Repository of the image that triggers the reload
        repository: kiwigrid/k8s-sidecar
        # -- Tag for the image that triggers the reload
        tag: 2.5.0
      imagePullPolicy: IfNotPresent
      # -- Port for sidecar health probes
      healthPort: 8060
      resources:
        {}
        #   limits:
        #     cpu: 100m
        #     memory: 100Mi
        #   requests:
        #     cpu: 50m
        #     memory: 50Mi
      # -- Enables additional volume mounts for the config auto-reload container
      additionalVolumeMounts:
        []
        #   - name: auto-reload-config
        #     mountPath: /var/config/logger
        #   - name: auto-reload-logs
        #     mountPath: /var/log/auto_reload
      # -- Config auto-reload logging settings
      logging:
        # See default settings https://github.com/kiwigrid/k8s-sidecar/blob/master/src/logger.py
        configuration:
          # -- Enables custom log config utilizing using the settings below.
          override: false
          logLevel: INFO
          formatter: JSON
          logToConsole: true
          logToFile: false
          maxBytes: 1024
          backupCount: 3

      # -- The scheme to use when connecting to the Jenkins configuration as code endpoint
      scheme: http
      # -- Skip TLS verification when connecting to the Jenkins configuration as code endpoint
      skipTlsVerify: false

      # -- How many connection-related errors to retry on
      reqRetryConnect: 10
      # -- How many seconds to wait before updating config-maps/secrets (sets METHOD=SLEEP on the sidecar)
      sleepTime:

      # -- Environment variable sources for the Jenkins Config as Code auto-reload container
      envFrom: []
      # -- Environment variables for the Jenkins Config as Code auto-reload container
      env: []
      #   - name: REQ_TIMEOUT
      #     value: "30"

      # SSH port value can be set to any unused TCP port. The default, 1044, is a non-standard SSH port that has been chosen at random.
      # This is only used to reload JCasC config from the sidecar container running in the Jenkins controller pod.
      # This TCP port will not be open in the pod (unless you specifically configure this), so Jenkins will not be
      # accessible via SSH from outside the pod. Note if you use non-root pod privileges (runAsUser & fsGroup),
      # this must be > 1024:
      sshTcpPort: 1044
      # folder in the pod that should hold the collected dashboards:
      folder: "/var/jenkins_home/casc_configs"

      # If specified, the sidecar will search for JCasC config-maps inside this namespace.
      # Otherwise, the namespace in which the sidecar is running will be used.
      # It's also possible to specify ALL to search in all namespaces:
      # searchNamespace:
      # -- Enable container security context
      containerSecurityContext:
        readOnlyRootFilesystem: true
        allowPrivilegeEscalation: false

    # -- Configures additional sidecar container(s) for the Jenkins controller
    additionalSidecarContainers: []
    ## The example below runs the client for https://smee.io as sidecar container next to Jenkins,
    ## that allows triggering build behind a secure firewall.
    ## https://jenkins.io/blog/2019/01/07/webhook-firewalls/#triggering-builds-with-webhooks-behind-a-secure-firewall
    ##
    ## Note: To use it you should go to https://smee.io/new and update the url to the generated one.
    # - name: smee
    #   image: docker.io/twalter/smee-client:1.0.2
    #   args: ["--port", "{{ .Values.controller.servicePort }}", "--path", "/github-webhook/", "--url", "https://smee.io/new"]
    #   resources:
    #     limits:
    #       cpu: 50m
    #       memory: 128Mi
    #     requests:
    #       cpu: 10m
    #       memory: 32Mi

  # -- Name of the Kubernetes scheduler to use
  schedulerName: ""

  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # -- Node labels for pod assignment
  nodeSelector: {}

  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  # -- Toleration labels for pod assignment
  tolerations: []
  # -- Set TerminationGracePeriodSeconds
  terminationGracePeriodSeconds:
  # -- Set the termination message path
  terminationMessagePath:
  # -- Set the termination message policy
  terminationMessagePolicy:

  # -- Affinity settings
  affinity: {}

  # Leverage a priorityClass to ensure your pods survive resource shortages
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  # -- The name of a `priorityClass` to apply to the controller pod
  priorityClassName:

  # -- Annotations for controller pod
  podAnnotations: {}
  # -- Annotations for controller StatefulSet
  statefulSetAnnotations: {}

  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  # -- Update strategy for StatefulSet
  updateStrategy: {}

  # -- Topology spread constraints
  topologySpreadConstraints: {}

  # Expose Prometheus metrics
  prometheus:
    # If enabled, add the prometheus plugin to the list of plugins to install
    # https://plugins.jenkins.io/prometheus

    # -- Enables prometheus service monitor
    enabled: false
    # -- How often prometheus should scrape metrics
    scrapeInterval: 10s


agent:
  # -- Enable Kubernetes plugin jnlp-agent podTemplate
  enabled: true
  # -- The name of the pod template to use for providing default values
  defaultsProviderTemplate: ""

  # Useful for not including a serviceAccount in the template if `false`
  # -- Use `serviceAccountAgent.name` as the default value for defaults template `serviceAccount`
  useDefaultServiceAccount: true

  # -- Override the default service account
  # @default -- `serviceAccountAgent.name` if `agent.useDefaultServiceAccount` is `true`
  serviceAccount:

  # -- Custom Pod labels (an object with `label-key: label-value` pairs)
  podLabels:
    k8s: "true"
  image:
    # -- Registry to pull the agent jnlp image from
    registry: ""
    # -- Repository to pull the agent jnlp image from
    repository: "jenkins/inbound-agent"
    # -- Tag of the image to pull
    tag: "3355.v388858a_47b_33-7"
  # -- Configure working directory for default agent
  workingDir: "/home/jenkins/agent"
  nodeUsageMode: "NORMAL"
  # -- Append Jenkins labels to the agent
  customJenkinsLabels: []
  # -- Name of the secret to be used to pull the image
  imagePullSecretName:
  componentName: "jenkins-agent"
  # -- Enables agent communication via websockets
  websocket: false
  directConnection: false
  # -- Agent privileged container
  privileged: false
  # -- Configure container user
  runAsUser:
  # -- Configure container group
  runAsGroup:
  # -- Enables the agent to use the host network
  hostNetworking: false
  # -- Resources allocation (Requests and Limits)
  resources:
    requests:
      cpu: "512m"
      memory: "512Mi"
      # ephemeralStorage:
    limits:
      cpu: "512m"
      memory: "512Mi"
      # ephemeralStorage:
  livenessProbe: {}
  #  execArgs: "cat /tmp/healthy"
  #  failureThreshold: 3
  #  initialDelaySeconds: 0
  #  periodSeconds: 10
  #  successThreshold: 1
  #  timeoutSeconds: 1

  # You may want to change this to true while testing a new image
  # -- Always pull agent container image before build
  alwaysPullImage: false
  # When using Pod Security Admission in the Agents namespace with the restricted Pod Security Standard,
  # the jnlp container cannot be scheduled without overriding its container definition with a securityContext.
  # This option allows to automatically inject in the jnlp container a securityContext
  # that is suitable for the use of the restricted Pod Security Standard.
  # -- Set a restricted securityContext on jnlp containers
  restrictedPssSecurityContext: false
  # Controls how agent pods are retained after the Jenkins build completes
  # Possible values: Always, Never, OnFailure
  podRetention: "Always"
  # Disable if you do not want the Yaml the agent pod template to show up
  # in the job Console Output. This can be helpful for either security reasons
  # or simply to clean up the output to make it easier to read.
  showRawYaml: true

  # You can define the volumes that you want to mount for this container
  # Allowed types are: ConfigMap, EmptyDir, EphemeralVolume, HostPath, Nfs, PVC, Secret
  # Configure the attributes as they appear in the corresponding Java class for that type
  # https://github.com/jenkinsci/kubernetes-plugin/tree/master/src/main/java/org/csanchez/jenkins/plugins/kubernetes/volumes
  # -- Additional volumes
  volumes: []
  # - type: ConfigMap
  #   configMapName: myconfigmap
  #   mountPath: /var/myapp/myconfigmap
  # - type: EmptyDir
  #   mountPath: /var/myapp/myemptydir
  #   memory: false
  # - type: EphemeralVolume
  #   mountPath: /var/myapp/myephemeralvolume
  #   accessModes: ReadWriteOnce
  #   requestsSize: 10Gi
  #   storageClassName: mystorageclass
  # - type: HostPath
  #   hostPath: /var/lib/containers
  #   mountPath: /var/myapp/myhostpath
  # - type: Nfs
  #   mountPath: /var/myapp/mynfs
  #   readOnly: false
  #   serverAddress: "192.0.2.0"
  #   serverPath: /var/lib/containers
  # - type: PVC
  #   claimName: mypvc
  #   mountPath: /var/myapp/mypvc
  #   readOnly: false
  # - type: Secret
  #   defaultMode: "600"
  #   mountPath: /var/myapp/mysecret
  #   secretName: mysecret
  # Pod-wide environment, these vars are visible to any container in the agent pod

  # You can define the workspaceVolume that you want to mount for this container
  # Allowed types are: DynamicPVC, EmptyDir, EphemeralVolume, HostPath, Nfs, PVC
  # Configure the attributes as they appear in the corresponding Java class for that type
  # https://github.com/jenkinsci/kubernetes-plugin/tree/master/src/main/java/org/csanchez/jenkins/plugins/kubernetes/volumes/workspace
  # -- Workspace volume (defaults to EmptyDir)
  workspaceVolume:
    type: PVC
    claimName: jenkins-pvc
    readOnly: false
    subPath: agent
  ## DynamicPVC example
  # - type: DynamicPVC
  #   configMapName: myconfigmap
  ## EmptyDir example
  # - type: EmptyDir
  #   memory: false
  ## EphemeralVolume example
  # - type: EphemeralVolume
  #   accessModes: ReadWriteOnce
  #   requestsSize: 10Gi
  #   storageClassName: mystorageclass
  ## HostPath example
  # - type: HostPath
  #   hostPath: /var/lib/containers
  ## NFS example
  # - type: Nfs
  #   readOnly: false
  #   serverAddress: "192.0.2.0"
  #   serverPath: /var/lib/containers
  ## PVC example
  # - type: PVC
  #   claimName: mypvc
  #   readOnly: false

  # Pod-wide environment, these vars are visible to any container in the agent pod
  # -- Environment variables for the agent Pod
  envVars: []
  # - name: PATH
  #   value: /usr/local/bin
  # -- Mount a secret as environment variable
  secretEnvVars: []
  # - key: PATH
  #   optional: false # default: false
  #   secretKey: MY-K8S-PATH
  #   secretName: my-k8s-secret

  # -- Node labels for pod assignment
  nodeSelector: {}
  # Key Value selectors. Ex:
  # nodeSelector
  #   jenkins-agent: v1

  # -- Command to execute when side container starts
  command:
  # -- Arguments passed to command to execute
  args: "${computer.jnlpmac} ${computer.name}"
  # -- Side container name
  sideContainerName: "jnlp"

  # Doesn't allocate pseudo TTY by default
  # -- Allocate pseudo tty to the side container
  TTYEnabled: false
  # -- Max number of agents to launch for a whole cluster.
  containerCap: 10
  # -- Max number of agents to launch for this type of agent
  instanceCap: 2147483647
  # -- Agent Pod base name
  podName: "default"

  # Enables garbage collection of orphan pods for this Kubernetes cloud. (beta)
  garbageCollection:
    # -- When enabled, Jenkins will periodically check for orphan pods that have not been touched for the given timeout period and delete them.
    enabled: false
    # -- Namespaces to look at for garbage collection, in addition to the default namespace defined for the cloud. One namespace per line.
    namespaces: ""
    # namespaces: |-
    #   namespaceOne
    #   namespaceTwo
    # -- Timeout value for orphaned pods
    timeout: 300

  # -- Allows the Pod to remain active for reuse until the configured number of minutes has passed since the last step was executed on it
  idleMinutes: 10

  # The raw yaml of a Pod API Object, for example, this allows usage of toleration for agent pods.
  # https://github.com/jenkinsci/kubernetes-plugin#using-yaml-to-define-pod-templates
  # https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  # -- The raw yaml of a Pod API Object to merge into the agent spec
  yamlTemplate: ""
  # yamlTemplate: |-
  #   apiVersion: v1
  #   kind: Pod
  #   spec:
  #     tolerations:
  #     - key: "key"
  #       operator: "Equal"
  #       value: "value"

  # -- Defines how the raw yaml field gets merged with yaml definitions from inherited pod templates. Possible values: "merge" or "override"
  yamlMergeStrategy: "override"
  # -- Controls whether the defined yaml merge strategy will be inherited if another defined pod template is configured to inherit from the current one
  inheritYamlMergeStrategy: false
  # -- Timeout in seconds for an agent to be online
  connectTimeout: 100
  # -- Annotations to apply to the pod
  annotations: {}

  # Containers specified here are added to all agents. Set key empty to remove container from additional agents.
  # -- Add additional containers to the agents
  additionalContainers: []
  #  - sideContainerName: dind
  #    image:
  #      repository: docker
  #      tag: dind
  #    command: dockerd-entrypoint.sh
  #    args: ""
  #    privileged: true
  #    resources:
  #      requests:
  #        cpu: 500m
  #        memory: 1Gi
  #      limits:
  #        cpu: 1
  #        memory: 2Gi

  # Useful when configuring agents only with the podTemplates value, since the default podTemplate populated by values mentioned above will be excluded in the rendered template.
  # -- Disable the default Jenkins Agent configuration
  disableDefaultAgent: true

  # Below is the implementation of custom pod templates for the default configured kubernetes cloud.
  # Add a key under podTemplates for each pod template. Each key (prior to | character) is just a label, and can be any value.
  # Keys are only used to give the pod template a meaningful name. The only restriction is they may only contain RFC 1123 \ DNS label
  # characters: lowercase letters, numbers, and hyphens. Each pod template can contain multiple containers.
  # For this pod templates configuration to be loaded, the following values must be set:
  # controller.JCasC.defaultConfig: true
  # Best reference is https://<jenkins_url>/configuration-as-code/reference#Cloud-kubernetes. The example below creates a python pod template.
  # -- Configures extra pod templates for the default kubernetes cloud
  podTemplates:
    rhel9: |
      - name: rhel9
        label: rhel9
        containers:
          - name: rhel9-container
            image: registry.access.redhat.com/ubi9/ubi:9.5
            command: "/bin/sh"
            args: "-c cat"
            ttyEnabled: true
            resourceRequestCpu: "512m"
            resourceRequestMemory: "512Mi"
            resourceLimitCpu: "1"
            resourceLimitMemory: "1024Mi"
    golang: |
      - name: golang
        label: golang
        containers:
          - name: golang-container
            image: golang:latest
            command: "/bin/sh"
            args: "-c cat"
            ttyEnabled: true
            resourceRequestCpu: "512m"
            resourceRequestMemory: "512Mi"
            resourceLimitCpu: "2"
            resourceLimitMemory: "2048Mi"
    python-3.13: |
      - name: python-3.13
        label: python-3.13
        containers:
          - name: python-container
            image: python:3.13-slim
            command: "/bin/sh"
            args: "-c cat"
            ttyEnabled: true
            resourceRequestCpu: "512m"
            resourceRequestMemory: "512Mi"
            resourceLimitCpu: "1"
            resourceLimitMemory: "1024Mi"

# Inherits all values from `agent` so you only need to specify values which differ
# -- Configure additional
additionalAgents: {}
#  maven:
#    podName: maven
#    customJenkinsLabels: maven
#    # An example of overriding the jnlp container
#    # sideContainerName: jnlp
#    image:
#      repository: jenkins/jnlp-agent-maven
#      tag: latest
#  python:
#    podName: python
#    customJenkinsLabels: python
#    sideContainerName: python
#    image:
#      repository: python
#      tag: "3"
#    command: "/bin/sh -c"
#    args: "cat"
#    TTYEnabled: true

# Here you can add additional clouds
# They inherit all values from the default cloud (including the main agent), so
# you only need to specify values which differ. If you want to override
# default additionalAgents with the additionalClouds.additionalAgents set
# additionalAgentsOverride to `true`.
additionalClouds: {}
#  remote-cloud-1:
#    kubernetesURL: https://api.remote-cloud.com
#    additionalAgentsOverride: true
#    additionalAgents:
#      maven-2:
#        podName: maven-2
#        customJenkinsLabels: maven
#        # An example of overriding the jnlp container
#        # sideContainerName: jnlp
#        image:
#          repository: jenkins/jnlp-agent-maven
#          tag: latest
#        namespace: my-other-maven-namespace
#  remote-cloud-2:
#    kubernetesURL: https://api.remote-cloud.com

persistence:
  # -- Enable the use of a Jenkins PVC
  enabled: true

  # A manually managed Persistent Volume and Claim
  # Requires persistence.enabled: true
  # If defined, PVC must be created manually before volume will be bound
  # -- Provide the name of a PVC
  existingClaim: jenkins-pvc

  # jenkins data Persistent Volume Storage Class
  # If defined, storageClassName: <storageClass>
  # If set to "-", storageClassName: "", which disables dynamic provisioning
  # If undefined (the default) or set to null, no storageClassName spec is
  #   set, choosing the default provisioner (gp2 on AWS, standard on GKE, AWS & OpenStack)
  # -- Storage class for the PVC
  storageClass:
  # -- Annotations for the PVC
  annotations: {}
  # -- Labels for the PVC
  labels: {}
  # -- The PVC access mode
  accessMode: "ReadWriteOnce"
  # -- The size of the PVC
  size: "8Gi"

  # ref: https://kubernetes.io/docs/concepts/storage/volume-pvc-datasource/
  # -- Existing data source to clone PVC from
  dataSource: {}
  #   name: PVC-NAME
  #   kind: PersistentVolumeClaim

  # -- SubPath for jenkins-home mount
  subPath: controller
  # -- Additional volumes
  volumes:
    - name: smoke-tests-jenkinsfiles
      configMap:
        name: smoke-tests-jenkinsfiles
  #  - name: nothing
  #    emptyDir: {}

  # -- Additional mounts
  mounts:
    - mountPath: /var/jenkins_home/smoke-tests-jenkinsfiles
      name: smoke-tests-jenkinsfiles
      readOnly: true
  #  - mountPath: /var/nothing
  #    name: nothing
  #    readOnly: true

networkPolicy:
  # -- Enable the creation of NetworkPolicy resources
  enabled: false

  # For Kubernetes v1.4, v1.5 and v1.6, use 'extensions/v1beta1'
  # For Kubernetes v1.7, use 'networking.k8s.io/v1'
  # -- NetworkPolicy ApiVersion
  apiVersion: networking.k8s.io/v1
  # You can allow agents to connect from both within the cluster (from within specific/all namespaces) AND/OR from a given external IP range
  internalAgents:
    # -- Allow internal agents (from the same cluster) to connect to controller. Agent pods will be filtered based on PodLabels
    allowed: true
    # -- A map of labels (keys/values) that agent pods must have to be able to connect to controller
    podLabels: {}
    # -- A map of labels (keys/values) that agents namespaces must have to be able to connect to controller
    namespaceLabels:
      {}
      # project: myproject
  externalAgents:
    # -- The IP range from which external agents are allowed to connect to controller, i.e., 172.17.0.0/16
    ipCIDR:
    # -- A list of IP sub-ranges to be excluded from the allowlisted IP range
    except:
      []
      # - 172.17.1.0/24

## Install Default RBAC roles and bindings
rbac:
  # -- Whether RBAC resources are created
  create: true
  # -- Whether the Jenkins service account should be able to read Kubernetes secrets
  readSecrets: false
  # -- Whether the Jenkins service account should be able to use the OpenShift "nonroot" Security Context Constraints
  useOpenShiftNonRootSCC: false

serviceAccount:
  # -- Configures if a ServiceAccount with this name should be created
  create: true

  # The name of the ServiceAccount is autogenerated by default
  #  -- The name of the ServiceAccount to be used by access-controlled resources
  name:
  # -- Configures annotations for the ServiceAccount
  annotations: {}
  # -- Configures extra labels for the ServiceAccount
  extraLabels: {}
  # -- Controller ServiceAccount image pull secret
  imagePullSecretName:
  # -- Auto-mount ServiceAccount token
  automountServiceAccountToken: true

serviceAccountAgent:
  # -- Configures if an agent ServiceAccount should be created
  create: false

  # If not set and create is true, a name is generated using the fullname template
  # -- The name of the agent ServiceAccount to be used by access-controlled resources
  name:
  # -- Configures annotations for the agent ServiceAccount
  annotations: {}
  # -- Configures extra labels for the agent ServiceAccount
  extraLabels: {}
  # -- Agent ServiceAccount image pull secret
  imagePullSecretName:
  # -- Auto-mount ServiceAccount token
  automountServiceAccountToken: true

# -- Checks if any deprecated values are used
checkDeprecation: true

awsSecurityGroupPolicies:
  enabled: false
  policies:
    - name: ""
      securityGroupIds: []
      podSelector: {}

# Here you can configure unit tests values when executing the helm unittest in the CONTRIBUTING.md
helmtest:
  # A testing framework for bash
  bats:
    # Bash Automated Testing System (BATS)
    image:
      # -- Registry of the image used to test the framework
      registry: "docker.io"
      # -- Repository of the image used to test the framework
      repository: "bats/bats"
      # -- Tag of the image to test the framework
      tag: "1.13.0"
